% SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
% SPDX-License-Identifier: Apache-2.0
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
% http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

function table_ML_datasets = proc_ML_dataset(SimCtrl, carrier, new_ML_dataset_content)

    
    FAPIpdu                             = new_ML_dataset_content.FAPIpdu;   
    Gtruth                              = new_ML_dataset_content.Gtruth;
    Xtf_all_UEs                         = new_ML_dataset_content.Xtf;
    current_time_ns                     = round(SimCtrl.ml.dataset.current_time_sec*1e9); 
    num_pdus                            = length(FAPIpdu);
    num_pusch_pdus                      = sum(cellfun(@(x) strcmp(x.type,'pusch'),FAPIpdu));
    num_pucch_pdus                      = sum(cellfun(@(x) strcmp(x.type,'pucch'),FAPIpdu));
    num_UEgroups                        = length(unique(cellfun(@(x) x.idxUeg,FAPIpdu)));
    for idx_pdu = 1:num_pdus
        if strcmp(SimCtrl.ml.dataset.channel,'pusch') && strcmp(FAPIpdu{idx_pdu}.type,'pusch')
            % some precalc
            num_sym_per_slot                = carrier.N_symb_slot;
            num_data_sym_per_slot           = num_sym_per_slot-sum(FAPIpdu{idx_pdu}.DmrsSymbPos);
            idxUeg                          = FAPIpdu{idx_pdu}.idxUeg;
            idxUE                           = FAPIpdu{idx_pdu}.idxUE;
            FAPIpdu_this_idxUeg             = FAPIpdu(find(cellfun(@(x) x.idxUeg==idxUeg,FAPIpdu)));
            idx_UEs_this_idxUeg             = cellfun(@(x) x.idxUE,FAPIpdu_this_idxUeg);
%             if ~all(idx_UEs_this_idxUeg==([0:length(idx_UEs_this_idxUeg)-1]))
%                 error('UE idx should be in ordering! Please do sth.')
%             end
            num_layers_this_pdu     = FAPIpdu{idx_pdu}.nrOfLayers;            
            Xtf_this_UE             = Xtf_all_UEs{idxUE+1};
            Xtf_this_pdu            = zeros(carrier.N_sc,num_sym_per_slot,num_layers_this_pdu);
            idx_REs_this_pdu        = ((FAPIpdu{idx_pdu}.BWPStart + FAPIpdu{idx_pdu}.rbStart)*12+1):(FAPIpdu{idx_pdu}.BWPStart + FAPIpdu{idx_pdu}.rbStart + FAPIpdu{idx_pdu}.rbSize)*12;
            Xtf_this_pdu(idx_REs_this_pdu,:,1:num_layers_this_pdu) = Xtf_this_UE(idx_REs_this_pdu,:,1:num_layers_this_pdu);  
            Xtf_this_pdu_shape      = size(Xtf_this_pdu);
            Xtf_this_pdu_vec        = reshape(permute(Xtf_this_pdu, [3,2,1]),1,[]);

            if idx_pdu == 1 % just need to log it once per slot for Ytf
                Ytf             = new_ML_dataset_content.Ytf; % Ytf is in shape [Nsc, Nsym, Nant]
                Ytf_shape       = size(Ytf);
                Ytf_reshaped    = permute(Ytf, [3,2,1]);
                Ytf_vector      = reshape(Ytf_reshaped,1,[]);
            else
                Ytf_shape       = [];
                Ytf_vector      = [];
            end
            pusch_pdus_this_UE = Gtruth{idxUE+1}.pusch;
            idx_pdu_to_extract_for_gt = find(cellfun(@(x) x.idxUeg==idxUeg, pusch_pdus_this_UE));
            % ChEst
            ChEst_this_UE = SimCtrl.ml.dataset.ChEst_perUE{idxUE+1}.per_pdu;
            idx_pdu_to_extract_for_chest = find(cellfun(@(x) x.idxUeg==idxUeg, ChEst_this_UE));
            Hest = ChEst_this_UE{idx_pdu_to_extract_for_chest}.Hest;
            Hest_vec = reshape(permute(Hest, [4,3,2,1]),1,[]);
            Hest_shape = size(Hest);
            % Genie channel
            ChGenie_this_UE = SimCtrl.ml.dataset.ChGenie_perUE{idxUE+1}.per_pdu;
            idx_pdu_to_extract_for_chgenie = find(cellfun(@(x) x.idxUeg==idxUeg, ChGenie_this_UE));
            Hgenie = ChGenie_this_UE{idx_pdu_to_extract_for_chgenie}.Hgenie;
            Hgenie_vec = reshape(permute(Hgenie, [4,3,2,1]),1,[]);
            Hgenie_shape = size(Hgenie);
            % populate a row
            new_dict = py.dict(pyargs(...
            'timestamp',                    current_time_ns, ...
            'pduIdx',                       idx_pdu, ...
            'SFN',                          mod(carrier.idxFrame, 1024), ...
            'Slot',                         carrier.idxSlot, ...
            'nPDUs',                        num_pdus, ...
            'RachPresent',                  0, ...
            'nULSCH',                       num_pusch_pdus, ...
            'nULCCH',                       num_pucch_pdus, ...
            'nGroup',                       num_UEgroups, ...
            'PDUSize',                      65535, ...
            'pduBitmap',                    1, ...
            'RNTI',                         FAPIpdu{idx_pdu}.RNTI, ...
            'Handle',                       2^64-1, ...
            'BWPSize',                      FAPIpdu{idx_pdu}.BWPSize, ...
            'BWPStart',                     FAPIpdu{idx_pdu}.BWPStart, ...
            'SubcarrierSpacing',            FAPIpdu{idx_pdu}.SubcarrierSpacing, ...
            'CyclicPrefix',                 FAPIpdu{idx_pdu}.CyclicPrefix, ...
            'targetCodeRate',               FAPIpdu{idx_pdu}.targetCodeRate, ...
            'qamModOrder',                  FAPIpdu{idx_pdu}.qamModOrder, ...
            'mcsIndex',                     FAPIpdu{idx_pdu}.mcsIndex, ...
            'mcsTable',                     FAPIpdu{idx_pdu}.mcsTable, ...
            'TransformPrecoding',           FAPIpdu{idx_pdu}.TransformPrecoding, ...
            'dataScramblingId',             FAPIpdu{idx_pdu}.dataScramblingId, ...
            'nrOfLayers',                   FAPIpdu{idx_pdu}.nrOfLayers, ...
            'DmrsSymbPos',                  py.numpy.array(FAPIpdu{idx_pdu}.DmrsSymbPos).astype('bool'), ...
            'dmrsConfigType',               FAPIpdu{idx_pdu}.dmrsConfigType, ...
            'ulDmrsScramblingId',           FAPIpdu{idx_pdu}.dmrsConfigType, ...
            'puschIdentity',                FAPIpdu{idx_pdu}.puschIdentity, ...
            'SCID',                         FAPIpdu{idx_pdu}.SCID, ...
            'numDmrsCdmGrpsNoData',         FAPIpdu{idx_pdu}.numDmrsCdmGrpsNoData, ...
            'dmrsPorts',                    bit2int(FAPIpdu{idx_pdu}.dmrsPorts.', 16), ...
            'resourceAlloc',                FAPIpdu{idx_pdu}.resourceAlloc, ...
            'rbBitmap',                     py.numpy.array([]), ...
            'rbStart',                      FAPIpdu{idx_pdu}.rbStart, ...
            'rbSize',                       FAPIpdu{idx_pdu}.rbSize, ...
            'VRBtoPRBMapping',              FAPIpdu{idx_pdu}.VRBtoPRBMapping, ...
            'FrequencyHopping',             FAPIpdu{idx_pdu}.FrequencyHopping, ...
            'txDirectCurrentLocation',      FAPIpdu{idx_pdu}.txDirectCurrentLocation, ...
            'uplinkFrequencyShift7p5khz',   FAPIpdu{idx_pdu}.uplinkFrequencyShift7p5khz, ...
            'StartSymbolIndex',             FAPIpdu{idx_pdu}.StartSymbolIndex, ...
            'NrOfSymbols',                  FAPIpdu{idx_pdu}.NrOfSymbols, ...
            'idxUeg',                       FAPIpdu{idx_pdu}.idxUeg, ...
            'idxUE',                        FAPIpdu{idx_pdu}.idxUE, ...
            'nUE_inUeg',                    length(idx_UEs_this_idxUeg), ...
            'puschData',                    0, ...
            'puschUci',                     0, ...
            'puschPtrs',                    0, ...
            'dftsOfdm',                     0, ...
            'Beamforming',                  0, ...
            'HarqID',                       0, ...
            'PDULen',                       2^64-1, ...
            'UL_CQI',                       2^8-1, ...
            'TimingAdvance',                2^16-1, ...
            'RSSI',                         2^16-1, ...
            'macPdu',                       0, ...
            'TbCrcStatus',                  FAPIpdu{idx_pdu}.tbErr, ...
            'NumCb',                        length(FAPIpdu{idx_pdu}.cbErr), ...
            'CbCrcStatus',                  py.numpy.atleast_1d(FAPIpdu{idx_pdu}.cbErr.').astype('bool'), ...
            'channel_model_type',           SimCtrl.ml.dataset.channel_model.type, ...
            'channel_model_SNR',            SimCtrl.ml.dataset.channel_model.SNR, ...%'interf_channel_model_SIR',     SimCtrl.ml.dataset.interference_channel_model.SIR, ...
            'gt_coded_rm_bit_payload',      py.numpy.array(double(pusch_pdus_this_UE{idx_pdu_to_extract_for_gt}.TbScramCbs.')).astype('bool'), ...
            'gt_data_symbols_i',            py.numpy.array(real(pusch_pdus_this_UE{idx_pdu_to_extract_for_gt}.Qams.')).astype('float32'), ...
            'gt_data_symbols_q',            py.numpy.array(imag(pusch_pdus_this_UE{idx_pdu_to_extract_for_gt}.Qams.')).astype('float32'), ...
            'gt_Xtf_i',                     py.numpy.array(real(Xtf_this_pdu_vec)).astype('float32'), ...
            'gt_Xtf_q',                     py.numpy.array(imag(Xtf_this_pdu_vec)).astype('float32'), ...
            'gt_Xtf_shape',                 py.numpy.array(Xtf_this_pdu_shape), ...
            'Ytf_i',                        py.numpy.array(real(Ytf_vector)).astype('float32'), ...
            'Ytf_q',                        py.numpy.array(imag(Ytf_vector)).astype('float32'), ...
            'Ytf_shape',                    py.numpy.array(Ytf_shape), ...
            'chan_est_i',                   py.numpy.array(real(Hest_vec)).astype('float32'), ...
            'chan_est_q',                   py.numpy.array(imag(Hest_vec)).astype('float32'), ...
            'chan_est_shape',               py.numpy.array(Hest_shape), ...
            'errInd',                       0, ...
            'gt_info_bit_payload',          py.numpy.array(FAPIpdu{idx_pdu}.payload).astype('bool'), ...
            'gt_channel_i',                 py.numpy.array(real(Hgenie_vec)).astype('float32'), ...
            'gt_channel_q',                 py.numpy.array(imag(Hgenie_vec)).astype('float32'), ...
            'gt_channel_shape',             py.numpy.array(Hgenie_shape), ...
            'gt_time_offset',               py.numpy.array([]), ...
            'gt_freq_offset',               py.numpy.array([]) ...
            ));
            
        else
            error('Only PUSCH are supported for now.')
        end
        SimCtrl.ml.dataset.table_ML_datasets = SimCtrl.ml.dataset.table_ML_datasets.append(new_dict,ignore_index=true); % new_dict{'NumCb'}
%         if double(SimCtrl.ml.dataset.table_ML_datasets.shape{1})==0
%             SimCtrl.ml.dataset.table_ML_datasets = py.pandas.DataFrame(new_dict);
%         else
%             SimCtrl.ml.dataset.table_ML_datasets = py.pandas.concat({SimCtrl.ml.dataset.table_ML_datasets, new_dict},ignore_index=true,axis=0,join='outer', sort=false);
%         end
    end
    table_ML_datasets = SimCtrl.ml.dataset.table_ML_datasets;
% py.list(py.numpy.array(FAPIpdu{idx_pdu}.payload).astype('float')), ...
%     table_ML_datasets = vertcat(SimCtrl.ml.dataset.table_ML_datasets, new_row_table);
%     new_row_table   = table('Size', [num_pdus, num_variables], 'VariableTypes', SimCtrl.ml.dataset.ColumnCfg(:,1),'VariableNames', SimCtrl.ml.dataset.ColumnCfg(:,2));
%     new_row_table{idx_pdu, "timestamp"}         = current_time_ns;
%             new_row_table{idx_pdu, "pduIdx"}            = idx_pdu - 0; %FAPIpdu{idx_pdu}.puschPduIdx;
%             new_row_table{idx_pdu, "SFN"}               = mod(carrier.idxFrame, 1024);
%             new_row_table{idx_pdu, "Slot"}              = carrier.idxSlot;
%             new_row_table{idx_pdu, "nPDUs"}             = num_pdus;
%             new_row_table{idx_pdu, "RachPresent"}       = 0;% hard coding for now
%             new_row_table{idx_pdu, "nULSCH"}            = num_pusch_pdus;
%             new_row_table{idx_pdu, "nULCCH"}            = num_pucch_pdus;
%             new_row_table{idx_pdu, "nGroup"}            = num_UEgroups;
%             new_row_table{idx_pdu, "PDUSize"}           = 65535; % dummy value for now
%             new_row_table{idx_pdu, "pduBitmap"}         = 1; % Bit 0: puschData (Indicates data is expected on the PUSCH); Bit 1:puschUci (Indicates UCI is expected on the PUSCH); Bit 2: puschPtrs (Indicates PTRS included (FR2)); Bit 3: dftsOfdm (Indicates DFT S-OFDM transmission)
%             new_row_table{idx_pdu, "RNTI"}              = FAPIpdu{idx_pdu}.RNTI;
%             new_row_table{idx_pdu, "Handle"}            = 2^64-1; % dummy value for now
%             new_row_table{idx_pdu, "BWPSize"}           = FAPIpdu{idx_pdu}.BWPSize;
%             new_row_table{idx_pdu, "BWPStart"}          = FAPIpdu{idx_pdu}.BWPStart;
%             new_row_table{idx_pdu, "SubcarrierSpacing"} = FAPIpdu{idx_pdu}.SubcarrierSpacing;
%             new_row_table{idx_pdu, "CyclicPrefix"}      = FAPIpdu{idx_pdu}.CyclicPrefix;
%             new_row_table{idx_pdu, "targetCodeRate"}    = FAPIpdu{idx_pdu}.targetCodeRate;
%             new_row_table{idx_pdu, "qamModOrder"}       = FAPIpdu{idx_pdu}.qamModOrder;
%             new_row_table{idx_pdu, "mcsIndex"}          = FAPIpdu{idx_pdu}.mcsIndex;
%             new_row_table{idx_pdu, "mcsTable"}          = FAPIpdu{idx_pdu}.mcsTable;
%             new_row_table{idx_pdu, "TransformPrecoding"}= FAPIpdu{idx_pdu}.TransformPrecoding;
%             new_row_table{idx_pdu, "dataScramblingId"}  = FAPIpdu{idx_pdu}.dataScramblingId;
%             new_row_table{idx_pdu, "nrOfLayers"}        = FAPIpdu{idx_pdu}.nrOfLayers;
%             new_row_table{idx_pdu, "dmrsConfigType"}    = FAPIpdu{idx_pdu}.dmrsConfigType;
%             new_row_table{idx_pdu, "ulDmrsScramblingId"}= FAPIpdu{idx_pdu}.DmrsScramblingId;
%             new_row_table{idx_pdu, "puschIdentity"}     = FAPIpdu{idx_pdu}.puschIdentity;
%             new_row_table{idx_pdu, "SCID"}              = FAPIpdu{idx_pdu}.SCID;
%             new_row_table{idx_pdu, "numDmrsCdmGrpsNoData"}= FAPIpdu{idx_pdu}.numDmrsCdmGrpsNoData;
%             new_row_table{idx_pdu, "dmrsPorts"}         = bit2int(FAPIpdu{idx_pdu}.dmrsPorts.', 16);
%             new_row_table{idx_pdu, "resourceAlloc"}     = FAPIpdu{idx_pdu}.resourceAlloc;
%             new_row_table{idx_pdu, "rbBitmap"}          = cellstr(num2str([0])); % dummy value for now
%             new_row_table{idx_pdu, "rbStart"}           = FAPIpdu{idx_pdu}.rbStart;
%             new_row_table{idx_pdu, "rbSize"}            = FAPIpdu{idx_pdu}.rbSize;
%             new_row_table{idx_pdu, "VRBtoPRBMapping"}   = FAPIpdu{idx_pdu}.VRBtoPRBMapping;
%             new_row_table{idx_pdu, "FrequencyHopping"}  = FAPIpdu{idx_pdu}.FrequencyHopping;
%             new_row_table{idx_pdu, "txDirectCurrentLocation"}     = FAPIpdu{idx_pdu}.txDirectCurrentLocation;
%             new_row_table{idx_pdu, "uplinkFrequencyShift7p5khz"}  = FAPIpdu{idx_pdu}.uplinkFrequencyShift7p5khz;
%             new_row_table{idx_pdu, "StartSymbolIndex"}  = FAPIpdu{idx_pdu}.StartSymbolIndex;
%             new_row_table{idx_pdu, "NrOfSymbols"}       = FAPIpdu{idx_pdu}.NrOfSymbols;
%             new_row_table{idx_pdu, "puschData"}         = cellstr(''); % dummy for now
%             new_row_table{idx_pdu, "puschUci"}          = cellstr('');
%             new_row_table{idx_pdu, "puschPtrs"}         = cellstr('');
%             new_row_table{idx_pdu, "dftsOfdm"}          = cellstr('');
%             new_row_table{idx_pdu, "Beamforming"}       = cellstr('');
%             new_row_table{idx_pdu, "HarqID"}            = 0;
%             new_row_table{idx_pdu, "PDULen"}            = 2^64-1; % dummy for now
%             new_row_table{idx_pdu, "UL_CQI"}            = 2^8-1; % dummy for now
%             new_row_table{idx_pdu, "TimingAdvance"}     = 2^16-1; % dummy for now
%             new_row_table{idx_pdu, "RSSI"}              = 2^16-1; % dummy for now
%             new_row_table{idx_pdu, "macPdu"}            = cellstr(''); % dummy for now
%             new_row_table{idx_pdu, "TbCrcStatus"}       = FAPIpdu{idx_pdu}.tbErr;
%             new_row_table{idx_pdu, "NumCb"}             = length(FAPIpdu{idx_pdu}.cbErr);
%             new_row_table{idx_pdu, "CbCrcStatus"}       = cellstr(num2str(FAPIpdu{idx_pdu}.cbErr.'));
%             % some additional loggingl
%             idxUeg                          = FAPIpdu{idx_pdu}.idxUeg;
%             idxUE                           = FAPIpdu{idx_pdu}.idxUE;
%             pdus_this_idxUeg                = FAPIpdu(find(cellfun(@(x) x.idxUeg==1,FAPIpdu)));
%             idx_UEs_this_idxUeg             = cellfun(@(x) x.idxUE,pdus_this_idxUeg);
%             new_row_table{idx_pdu, "nUE"}   = length(idx_UEs_this_idxUeg);
%             new_row_table{idx_pdu, "idxUE"} = idxUE;
%             new_row_table{idx_pdu, "idxUeg"} = FAPIpdu{idx_pdu}.idxUeg;
%             % genie labels
%             new_row_table{idx_pdu, "gt_info_bit_payload"}= cellstr(num2str(FAPIpdu{idx_pdu}.payload));
%             if idx_pdu == 1 % just need to log it once per slot for Ytf
%                 Ytf             = new_ML_dataset_content.Ytf; % Ytf is in shape [Nsc, Nsym, Nant]
%                 Ytf_reshaped    = permute(Ytf, [3,2,1]);
%                 Ytf_vector      = reshape(Ytf_reshaped,1,[]);
%                 new_row_table{idx_pdu, "Ytf_i"}= cellstr(num2str(real(Ytf_vector)));
%                 new_row_table{idx_pdu, "Ytf_q"}= cellstr(num2str(imag(Ytf_vector)));
%             end
%             pusch_pdus_this_UE = Gtruth{idxUE+1}.pusch;
%             idx_pdu_to_extract = find(cellfun(@(x) x.idxUeg==idxUeg, pusch_pdus_this_UE));
%             new_row_table{idx_pdu, "gt_coded_rm_bit_payload"}= cellstr(num2str(pusch_pdus_this_UE{idx_pdu_to_extract}.TbScramCbs.'));
%             new_row_table{idx_pdu, "gt_data_symbols_i"}= cellstr(num2str(real(pusch_pdus_this_UE{idx_pdu_to_extract}.Qams).'));
%             new_row_table{idx_pdu, "gt_data_symbols_q"}= cellstr(num2str(imag(pusch_pdus_this_UE{idx_pdu_to_extract}.Qams).'));
%             % ChEst
%             ChEst_this_UE = SimCtrl.ml.dataset.ChEst_perUE{idxUE+1}.per_pdu;
%             idx_pdu_to_extract = find(cellfun(@(x) x.idxUeg==idxUeg, ChEst_this_UE));
%             Hest = ChEst_this_UE{idx_pdu_to_extract}.Hest;
%             Hest_vec = reshape(permute(Hest, [4,3,2,1]),1,[]);
%             new_row_table{idx_pdu, "chan_est_i"}= cellstr(num2str(real(Hest_vec)));
%             new_row_table{idx_pdu, "chan_est_q"}= cellstr(num2str(imag(Hest_vec)));
%             list_global_idx_UE = [list_global_idx_UE, idxUE];
    