/*
 * SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include "aerial-fh-driver/api.hpp"
#include "fh_generator.hpp"
#include "utils.hpp"
#include "cuphy_pti.hpp"

// #define TAG "FHGEN"

using namespace fh_gen;

FhGenerator* gen{};

void signal_handler(int signum)
{
    if(signum == SIGINT || signum == SIGTERM)
    {
        NVLOGC_FMT(TAG,"Signal {} received, preparing to exit..." ,signum);
        delete gen;
    }

    exit(0);
}

void usage()
{
    NVLOGC_FMT(TAG,"Usage: ./fh_generator <path_to_config_file> (-r)");
}


// Function generated by chatgpt
// Function to modify file name
char* modifyFileName(const char* path, const char* prefix) {
    // Find the last occurrence of '/' or '\'
    const char *lastSlash = strrchr(path, '/');
    const char *lastBackslash = strrchr(path, '\\');

    // Choose the last occurrence among '/' and '\'
    const char *lastSeparator = (lastSlash > lastBackslash) ? lastSlash : lastBackslash;

    // Allocate memory for the modified file name
    char *modifiedFileName;

    if (lastSeparator != NULL) {
        // If separator found, copy the prefix before it
        modifiedFileName = strdup(lastSeparator + 1);
    } else {
        // If no separator found, use the original path
        modifiedFileName = strdup(path);
    }

    // Find the last occurrence of '.' to get file extension
    const char *lastDot = strrchr(modifiedFileName, '.');

    // Modify the file name: prepend prefix and change extension to ".log"
    if (lastDot != NULL) {
        strcpy((char *)lastDot, ".log");
    } else {
        strcat(modifiedFileName, ".log");
    }

    // Prepend prefix
    char* prefixedFileName = (char*)malloc(strlen(modifiedFileName) + strlen(prefix) + 1);
    strcpy(prefixedFileName, prefix);
    strcat(prefixedFileName, modifiedFileName);

    // Free memory allocated by strdup
    free(modifiedFileName);

    return prefixedFileName;
}

int main(int argc, char* argv[])
{

    if(argc == 2)
    {
        char        yaml_file[1024];
        std::string relative_path = std::string("../../../../../").append(NVLOG_DEFAULT_CONFIG_FILE);
        nv_get_absolute_path(yaml_file, relative_path.c_str());
        char *nvlog_output_file_name = modifyFileName(argv[1], "fhgen_du_");
        pthread_t bg_thread_id = nvlog_fmtlog_init(yaml_file, nvlog_output_file_name, NULL);
        std::string config_file{argv[1]};
        signal(SIGINT, signal_handler);
        signal(SIGTERM, signal_handler);

        try
        {
            NVLOGC_FMT(TAG, "Starting FH Generator for DU side");
            gen = new FhGenerator(config_file, FhGenType::DU);
        }
        FH_GEN_CATCH_EXCEPTIONS();
        auto curr_time = now_ns();
        auto next_time = curr_time + 1000000000;
        while(!gen->exit_signal())
        {
            auto time = now_ns();
            if(time < next_time)
            {
                if(next_time - time > 75 * 1000)
                {
                    usleep(1000);
                }
                continue;
            }
            gen->print_periodic_counters();
            curr_time = next_time;
            next_time = curr_time + 1000000000;
        }
        sleep(1);
        delete gen;
        NVLOGC_FMT(TAG, "Closing FH Generator for DU side");
    }
    else if(argc == 3)
    {
        char        yaml_file[1024];
        std::string relative_path = std::string("../../../../../").append(NVLOG_DEFAULT_CONFIG_FILE);
        nv_get_absolute_path(yaml_file, relative_path.c_str());
        char *nvlog_output_file_name = modifyFileName(argv[1], "fhgen_ru_");
        pthread_t bg_thread_id = nvlog_fmtlog_init(yaml_file, nvlog_output_file_name, NULL);
        std::string ru{argv[2]};
        std::string config_file{argv[1]};
        signal(SIGINT, signal_handler);
        signal(SIGTERM, signal_handler);
        if(ru == "-r")
        {
            NVLOGC_FMT(TAG, "Starting FH Generator for RU side");
            try
            {
                gen = new FhGenerator(config_file, FhGenType::RU);
            }
            FH_GEN_CATCH_EXCEPTIONS();
            auto curr_time = now_ns();
            auto next_time = curr_time + 1000000000;
            while(!gen->exit_signal()) {
                auto time = now_ns();
                if(time < next_time)
                {
                    if(next_time - time > 75 * 1000)
                    {
                        usleep(1000);
                    }
                    continue;
                }
                gen->print_periodic_counters();
                curr_time = next_time;
                next_time = curr_time + 1000000000;
            }
            sleep(1);
            delete gen;
        }
        else
        {
            usage();
        }
        NVLOGC_FMT(TAG, "Closing FH Generator for RU side");

    }
    else
    {
        usage();
    }
}
