/*
 * SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#if !defined(OFDM_MOD_CUH_INCLUDED_)
#define OFDM_MOD_CUH_INCLUDED_

#include "ofdmCommonFunc.h"

namespace ofdm_modulate
{

//--------------------------------------------------------------------------------------------------------
// OFDM modulation

/**
 * @brief dynamic descriptor for OFDM modulation
 *
 * @param sqrt_N_IFFT_inverse: for normalized of ifft output, calculated on CPU, used on GPU
 * @param cpInfo: lengthï¼š2*N_symbol_slot; first N_symbol_slot containes the CP len for each symbol, second N_symbol_slot contains the accumulated CP len including this symbol
 * @param freqDataIn: length controlled by ofdmMod class, N_symbol_slot * N_sc * N_bsLayer or N_ueLayer
 * @param timeDataOut: length controlled by ofdmMod class, (N_symbol_slot * N_FFT + totalCP) * N_bsLayer or N_ueLayer
 *
 * @todo OFDM windowing implemented, not tested yet, DO NOT USE (keep ofdmWindowLen = 0)
 */
template <typename Tscalar, typename Tcomplex> 
struct ofdmModDynDescr_t{
    uint N_IFFT;
    float sqrt_N_IFFT_inverse;
    int N_symbol_slot;
    uint16_t * cpInfo;
    uint N_sc;
    uint mu;
    uint16_t N_bsLayer;
    uint16_t N_ueLayer;
    uint ofdmWindowLen;
    Tscalar * ofdmWindowCoe;
    Tcomplex * freqDataIn;
    Tcomplex * timeDataOut;
};

/**
 * @brief OFDM modulation class
 * perform ofdm modulation (IFFT) using cuFFTdx and add CP
 * output GPU buffer will be auto generated
 * @todo __half16 not tested, apply windowing 
 */
template <typename Tscalar, typename Tcomplex> 
class ofdmModulate
{
public:
    /**
     * @brief Construct a new ofdm Modulate object
     * 
     * @param cuphyCarrierPrms  carrier info
     * @param freqDataIn GPU memory address of tx freq signal ofdmMod does not check size
     * @param strm cuda stream to run ofdm demodulation 
     */
    ofdmModulate(cuphyCarrierPrms_t * cuphyCarrierPrms, Tcomplex * freqDataIn, cudaStream_t strm);
    ~ofdmModulate();
    ofdmModulate(ofdmModulate const&) = delete;
    ofdmModulate& operator=(ofdmModulate const&) = delete;

    /**
     * @brief run kernel to perform IFFT and add CP
     * use N_txlayer * N_symbol_slot/OFDM_FFTs_PER_BLOCK_CONST_ thread blocks to perform OFDM demodulation (FFT)
     *  thread block dims are auto generated by cuFFTdx
     * 
    *  @param enableSwapTxRx swap tx and rx
     * @param strm cuda stream to run, recommand be the same with config strm for synchronization
     */
    void run(uint8_t enableSwapTxRx, cudaStream_t strm);  // run kernel

    /**
     * @brief print sample time signals
     * 
     * @param printLen length of samples to print, 10 by defualt
     */
    void printTimeSample(int printLen = 10); // print sample time signals

    /**
     * @brief Get the tx Time Data Out object
     * 
     * @return Tcomplex* 
     */
    Tcomplex * getTimeDataOut() {return m_ofdmModdynDescprCpu -> timeDataOut; } 

    /**
     * @brief Get the total tx Time Data Len object
     * 
     * @return uint 
     */
    uint32_t getTimeDataLen() {return m_enableSwapTxRx ? m_timeDataLenUl : m_timeDataLenDl;}

    /**
     * @brief Save the carrier, tx freq and time data to hdf5 file
     */
    void saveOfdmModToH5File(cudaStream_t strm);

    /**
     * @brief return the length of samples per OFDM symbol (with CP)
     * 
     * @return std::vector<uint32_t> 
     */
    std::vector<uint32_t> getEachSymbolLenWithCP() { return m_eachSymbolLenWithCP; }

private:
    cuphyCarrierPrms_t * m_cuphyCarrierPrms;
    // dynamic descriptors for CPU and GPU
    ofdmModDynDescr_t<Tscalar, Tcomplex> * m_ofdmModdynDescprCpu;
    ofdmModDynDescr_t<Tscalar, Tcomplex> * m_ofdmModdynDescprGpu;
    ofdmLaunchCfg_t*    m_pOfdmModCfg; // lauch ofdm modulation kernel config
    ofdmLaunchCfg_t*    m_pWindowCfg; // lauch apply windowing kernel config
    // CP info for CPU and GPU
    uint16_t * m_cpInfoCpu;
    uint16_t * m_cpInfoGpu;
    // windowing coefficient (currently rcos) for CPU and GPU
    Tscalar * m_ofdmWindowCpu;
    Tscalar * m_ofdmWindowGpu;
    uint32_t m_freqDataLenDl, m_freqDataLenUl; // length of tx freq samples
    uint32_t m_timeDataLenDl, m_timeDataLenUl; // length of tx time samples
    uint8_t m_enableSwapTxRx;  // enable swap tx and rx
    std::vector<uint32_t> m_eachSymbolLenWithCP; // the number of samples per OFDM symbol
};

// Explicitly instantiate the template to resovle "undefined functions"
    template class ofdmModulate<__half, __half2>;
    template class ofdmModulate<float, cuComplex>; 
} // end of namespace ofdm_modulate

#endif // !defined(OFDM_MOD_CUH_INCLUDED_)